# channel_tracker.py
# Module (Cog) ƒë·ªÉ theo d√µi ho·∫°t ƒë·ªông c·ªßa c√°c k√™nh Discord.
# Phi√™n b·∫£n 4: S·ª≠a l·ªói logic, th√¥ng b√°o khi k√™nh ho·∫°t ƒë·ªông tr·ªü l·∫°i v√† ti·∫øp t·ª•c theo d√µi.

import discord
from discord.ext import commands, tasks
import psycopg2
import os
from datetime import datetime, timedelta, timezone

# --- C√°c h√†m t∆∞∆°ng t√°c v·ªõi Database (Synchronous) ---
DATABASE_URL = os.getenv('DATABASE_URL')

def db_connect():
    """K·∫øt n·ªëi t·ªõi database."""
    try:
        return psycopg2.connect(DATABASE_URL, sslmode='require')
    except Exception as e:
        print(f"[Tracker] L·ªói k·∫øt n·ªëi database: {e}")
        return None

def init_tracker_db():
    """T·∫°o ho·∫∑c c·∫≠p nh·∫≠t b·∫£ng 'tracked_channels' ƒë·ªÉ c√≥ c·ªôt tr·∫°ng th√°i."""
    conn = db_connect()
    if conn:
        try:
            with conn.cursor() as cur:
                # T·∫°o b·∫£ng n·∫øu ch∆∞a c√≥, th√™m c·ªôt is_inactive ƒë·ªÉ theo d√µi tr·∫°ng th√°i
                cur.execute("""
                    CREATE TABLE IF NOT EXISTS tracked_channels (
                        channel_id BIGINT PRIMARY KEY,
                        guild_id BIGINT NOT NULL,
                        user_id BIGINT NOT NULL,
                        notification_channel_id BIGINT NOT NULL,
                        added_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                        is_inactive BOOLEAN DEFAULT FALSE NOT NULL
                    );
                """)
                # C·ªë g·∫Øng th√™m c·ªôt is_inactive n·∫øu b·∫£ng ƒë√£ t·ªìn t·∫°i t·ª´ phi√™n b·∫£n c≈©
                # L·ªánh n√†y s·∫Ω kh√¥ng b√°o l·ªói n·∫øu c·ªôt ƒë√£ t·ªìn t·∫°i
                try:
                    cur.execute("ALTER TABLE tracked_channels ADD COLUMN is_inactive BOOLEAN DEFAULT FALSE NOT NULL;")
                    print("[Tracker] N√¢ng c·∫•p th√†nh c√¥ng: ƒê√£ th√™m c·ªôt 'is_inactive' v√†o database.")
                except psycopg2.errors.DuplicateColumn:
                    # C·ªôt ƒë√£ t·ªìn t·∫°i, b·ªè qua
                    pass
                conn.commit()
            print("[Tracker] B·∫£ng 'tracked_channels' trong database ƒë√£ s·∫µn s√†ng.")
        finally:
            conn.close()

def db_add_channel(channel_id, guild_id, user_id, notification_channel_id):
    """Th√™m m·ªôt k√™nh v√†o database, reset tr·∫°ng th√°i v·ªÅ 'ƒëang ho·∫°t ƒë·ªông'."""
    conn = db_connect()
    if conn:
        try:
            with conn.cursor() as cur:
                # Khi th√™m ho·∫∑c c·∫≠p nh·∫≠t, lu√¥n ƒë·∫∑t is_inactive = FALSE
                cur.execute(
                    """
                    INSERT INTO tracked_channels (channel_id, guild_id, user_id, notification_channel_id, is_inactive)
                    VALUES (%s, %s, %s, %s, FALSE)
                    ON CONFLICT (channel_id) DO UPDATE SET
                        user_id = EXCLUDED.user_id,
                        notification_channel_id = EXCLUDED.notification_channel_id,
                        is_inactive = FALSE;
                    """,
                    (channel_id, guild_id, user_id, notification_channel_id)
                )
                conn.commit()
        finally:
            conn.close()

def db_remove_channel(channel_id):
    """X√≥a m·ªôt k√™nh kh·ªèi database."""
    conn = db_connect()
    if conn:
        try:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM tracked_channels WHERE channel_id = %s;", (channel_id,))
                conn.commit()
        finally:
            conn.close()

def db_get_all_tracked():
    """L·∫•y danh s√°ch t·∫•t c·∫£ c√°c k√™nh ƒëang ƒë∆∞·ª£c theo d√µi v√† tr·∫°ng th√°i c·ªßa ch√∫ng."""
    conn = db_connect()
    if conn:
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT channel_id, guild_id, user_id, notification_channel_id, is_inactive FROM tracked_channels;")
                results = cur.fetchall()
                return results
        finally:
            conn.close()
    return []

def db_update_channel_status(channel_id, is_now_inactive: bool):
    """C·∫≠p nh·∫≠t tr·∫°ng th√°i 'is_inactive' cho m·ªôt k√™nh."""
    conn = db_connect()
    if conn:
        try:
            with conn.cursor() as cur:
                cur.execute("UPDATE tracked_channels SET is_inactive = %s WHERE channel_id = %s;", (is_now_inactive, channel_id))
                conn.commit()
        finally:
            conn.close()

# Ch·∫°y kh·ªüi t·∫°o/c·∫≠p nh·∫≠t DB m·ªôt l·∫ßn khi bot load module n√†y
init_tracker_db()

# --- C√°c th√†nh ph·∫ßn UI (Views, Modals) ---

class TrackByIDModal(discord.ui.Modal, title="Theo d√µi b·∫±ng ID K√™nh"):
    """Modal ƒë·ªÉ ng∆∞·ªùi d√πng nh·∫≠p ID c·ªßa k√™nh mu·ªën theo d√µi."""
    channel_id_input = discord.ui.TextInput(
        label="ID c·ªßa k√™nh c·∫ßn theo d√µi",
        placeholder="D√°n ID c·ªßa k√™nh vƒÉn b·∫£n v√†o ƒë√¢y...",
        required=True,
        min_length=17,
        max_length=20
    )

    async def on_submit(self, interaction: discord.Interaction):
        bot = interaction.client
        try:
            channel_id = int(self.channel_id_input.value)
        except ValueError:
            return await interaction.response.send_message("ID k√™nh kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªâ nh·∫≠p s·ªë.", ephemeral=True)

        channel_to_track = bot.get_channel(channel_id)
        if not isinstance(channel_to_track, discord.TextChannel):
            return await interaction.response.send_message("Kh√¥ng t√¨m th·∫•y k√™nh vƒÉn b·∫£n v·ªõi ID n√†y ho·∫∑c bot kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.", ephemeral=True)
        
        await bot.loop.run_in_executor(
            None, db_add_channel, channel_to_track.id, channel_to_track.guild.id, interaction.user.id, interaction.channel_id
        )

        embed = discord.Embed(
            title="üõ∞Ô∏è B·∫Øt ƒë·∫ßu theo d√µi",
            description=f"Th√†nh c√¥ng! Bot s·∫Ω theo d√µi k√™nh {channel_to_track.mention} trong server **{channel_to_track.guild.name}**.",
            color=discord.Color.green()
        )
        embed.set_footer(text=f"C·∫£nh b√°o s·∫Ω ƒë∆∞·ª£c g·ª≠i v·ªÅ k√™nh n√†y n·∫øu k√™nh kh√¥ng ho·∫°t ƒë·ªông.")
        await interaction.response.send_message(embed=embed, ephemeral=True)


class TrackByNameModal(discord.ui.Modal, title="Theo d√µi k√™nh tr√™n m·ªçi Server"):
    """Modal ƒë·ªÉ ng∆∞·ªùi d√πng nh·∫≠p t√™n k√™nh v√† bot s·∫Ω t√¨m tr√™n t·∫•t c·∫£ server."""
    channel_name_input = discord.ui.TextInput(
        label="Nh·∫≠p ch√≠nh x√°c t√™n k√™nh c·∫ßn theo d√µi",
        placeholder="V√≠ d·ª•: general, announcements, v.v.",
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True, thinking=True)
        bot = interaction.client
        channel_name = self.channel_name_input.value.strip().lower().replace('-', ' ')

        found_channels = []
        for guild in bot.guilds:
            if guild.get_member(interaction.user.id):
                target_channel = discord.utils.get(guild.text_channels, name=channel_name)
                if target_channel:
                    found_channels.append(target_channel)

        if not found_channels:
            await interaction.followup.send(f"Kh√¥ng t√¨m th·∫•y k√™nh n√†o t√™n `{self.channel_name_input.value}` trong c√°c server b·∫°n c√≥ m·∫∑t.", ephemeral=True)
            return

        for channel in found_channels:
            await bot.loop.run_in_executor(
                None, db_add_channel, channel.id, channel.guild.id, interaction.user.id, interaction.channel_id
            )

        server_list_str = "\n".join([f"‚Ä¢ **{c.guild.name}**" for c in found_channels])
        embed = discord.Embed(
            title="üõ∞Ô∏è B·∫Øt ƒë·∫ßu theo d√µi h√†ng lo·∫°t",
            description=f"ƒê√£ b·∫Øt ƒë·∫ßu theo d√µi **{len(found_channels)}** k√™nh t√™n `{self.channel_name_input.value}` t·∫°i:\n{server_list_str}",
            color=discord.Color.green()
        )
        embed.set_footer(text="C·∫£nh b√°o s·∫Ω ƒë∆∞·ª£c g·ª≠i v·ªÅ k√™nh n√†y n·∫øu c√≥ k√™nh kh√¥ng ho·∫°t ƒë·ªông.")
        await interaction.followup.send(embed=embed, ephemeral=True)

class TrackInitialView(discord.ui.View):
    """View ban ƒë·∫ßu v·ªõi hai l·ª±a ch·ªçn: theo d√µi b·∫±ng ID ho·∫∑c T√™n."""
    def __init__(self, author_id: int, bot: commands.Bot):
        super().__init__(timeout=180)
        self.author_id = author_id
        self.bot = bot

    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.author_id:
            await interaction.response.send_message("B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi d√πng l·ªánh n√†y!", ephemeral=True)
            return False
        return True

    @discord.ui.button(label="Theo d√µi b·∫±ng ID K√™nh", style=discord.ButtonStyle.primary, emoji="üÜî")
    async def track_by_id(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(TrackByIDModal())

    @discord.ui.button(label="Theo d√µi b·∫±ng T√™n K√™nh", style=discord.ButtonStyle.secondary, emoji="üìù")
    async def track_by_name(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(TrackByNameModal())


# --- Cog ch√≠nh ---
class ChannelTracker(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.inactivity_threshold_minutes = int(os.getenv('INACTIVITY_THRESHOLD_MINUTES', 7 * 24 * 60))
        self.check_activity.start()

    def cog_unload(self):
        self.check_activity.cancel()

    @tasks.loop(minutes=30)
    async def check_activity(self):
        print(f"[{datetime.now()}] [Tracker] B·∫Øt ƒë·∫ßu ki·ªÉm tra tr·∫°ng th√°i k√™nh...")
        
        tracked_channels_data = await self.bot.loop.run_in_executor(None, db_get_all_tracked)
        
        for channel_id, guild_id, user_id, notification_channel_id, was_inactive in tracked_channels_data:
            notification_channel = self.bot.get_channel(notification_channel_id)
            if not notification_channel:
                print(f"[Tracker] L·ªñI: Kh√¥ng t√¨m th·∫•y k√™nh th√¥ng b√°o {notification_channel_id}, x√≥a k√™nh {channel_id} kh·ªèi DB.")
                await self.bot.loop.run_in_executor(None, db_remove_channel, channel_id)
                continue

            channel_to_track = self.bot.get_channel(channel_id)
            if not channel_to_track:
                print(f"[Tracker] K√™nh {channel_id} kh√¥ng t·ªìn t·∫°i, ƒëang x√≥a kh·ªèi DB.")
                await self.bot.loop.run_in_executor(None, db_remove_channel, channel_id)
                continue
            
            try:
                last_message = await channel_to_track.fetch_message(channel_to_track.last_message_id) if channel_to_track.last_message_id else None
                last_activity_time = last_message.created_at if last_message else channel_to_track.created_at
                time_since_activity = datetime.now(timezone.utc) - last_activity_time
                
                is_currently_inactive = time_since_activity > timedelta(minutes=self.inactivity_threshold_minutes)
                user_to_notify = self.bot.get_user(user_id) or await self.bot.fetch_user(user_id)
                mention = user_to_notify.mention if user_to_notify else f"<@{user_id}>"

                # K·ªäCH B·∫¢N 1: K√™nh v·ª´a m·ªõi tr·ªü n√™n kh√¥ng ho·∫°t ƒë·ªông
                if is_currently_inactive and not was_inactive:
                    print(f"[Tracker] K√™nh {channel_id} ƒë√£ kh√¥ng ho·∫°t ƒë·ªông. G·ª≠i c·∫£nh b√°o.")
                    await self.bot.loop.run_in_executor(None, db_update_channel_status, channel_id, True)
                    
                    embed = discord.Embed(
                        title="‚ö†Ô∏è C·∫£nh b√°o K√™nh kh√¥ng ho·∫°t ƒë·ªông",
                        description=f"K√™nh {channel_to_track.mention} t·∫°i **{channel_to_track.guild.name}** ƒë√£ kh√¥ng c√≥ tin nh·∫Øn m·ªõi trong h∆°n **{self.inactivity_threshold_minutes}** ph√∫t.",
                        color=discord.Color.orange()
                    )
                    embed.add_field(name="L·∫ßn ho·∫°t ƒë·ªông cu·ªëi", value=f"<t:{int(last_activity_time.timestamp())}:R>", inline=False)
                    embed.set_footer(text=f"Thi·∫øt l·∫≠p b·ªüi {user_to_notify.display_name if user_to_notify else f'User ID: {user_id}'}")
                    await notification_channel.send(content=f"Th√¥ng b√°o cho {mention}:", embed=embed)

                # K·ªäCH B·∫¢N 2: K√™nh ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i
                elif not is_currently_inactive and was_inactive:
                    print(f"[Tracker] K√™nh {channel_id} ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i. G·ª≠i th√¥ng b√°o.")
                    await self.bot.loop.run_in_executor(None, db_update_channel_status, channel_id, False)

                    embed = discord.Embed(
                        title="‚úÖ K√™nh ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i",
                        description=f"K√™nh {channel_to_track.mention} t·∫°i **{channel_to_track.guild.name}** ƒë√£ c√≥ ho·∫°t ƒë·ªông m·ªõi.",
                        color=discord.Color.green()
                    )
                    embed.add_field(name="Ho·∫°t ƒë·ªông g·∫ßn nh·∫•t", value=f"<t:{int(last_activity_time.timestamp())}:R>", inline=False)
                    embed.set_footer(text=f"Bot s·∫Ω ti·∫øp t·ª•c theo d√µi k√™nh n√†y.")
                    await notification_channel.send(content=f"C·∫≠p nh·∫≠t cho {mention}:", embed=embed)
            
            except discord.Forbidden:
                print(f"[Tracker] L·ªói quy·ªÅn: Kh√¥ng th·ªÉ ƒë·ªçc l·ªãch s·ª≠ k√™nh {channel_to_track.name} ({channel_id}). B·ªè qua.")
            except Exception as e:
                print(f"[Tracker] L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra k√™nh {channel_id}: {e}")

    @check_activity.before_loop
    async def before_check_activity(self):
        await self.bot.wait_until_ready()

    @commands.command(name='track', help='Theo d√µi ho·∫°t ƒë·ªông c·ªßa m·ªôt k√™nh.')
    async def track(self, ctx: commands.Context):
        embed = discord.Embed(
            title="üõ∞Ô∏è Thi·∫øt l·∫≠p Theo d√µi K√™nh",
            description="Ch·ªçn ph∆∞∆°ng th·ª©c b·∫°n mu·ªën d√πng ƒë·ªÉ x√°c ƒë·ªãnh k√™nh c·∫ßn theo d√µi.",
            color=discord.Color.blue()
        )
        view = TrackInitialView(author_id=ctx.author.id, bot=self.bot)
        await ctx.send(embed=embed, view=view)

    @commands.command(name='untrack', help='Ng·ª´ng theo d√µi ho·∫°t ƒë·ªông c·ªßa m·ªôt k√™nh.')
    async def untrack(self, ctx: commands.Context, channel: discord.TextChannel = None):
        if channel is None:
            await ctx.send("Vui l√≤ng g·∫Øn th·∫ª k√™nh b·∫°n mu·ªën ng·ª´ng theo d√µi. V√≠ d·ª•: `!untrack #t√™n-k√™nh`", ephemeral=True)
            return
    
        tracked_channels_data = await self.bot.loop.run_in_executor(None, db_get_all_tracked)
        tracked_channel = next((tc for tc in tracked_channels_data if tc[0] == channel.id), None)
        
        if not tracked_channel:
            await ctx.send(f"K√™nh {channel.mention} hi·ªán kh√¥ng ƒë∆∞·ª£c theo d√µi.", ephemeral=True)
            return
            
        user_id_who_added = tracked_channel[2]
        if user_id_who_added != ctx.author.id and not ctx.author.guild_permissions.manage_channels:
            await ctx.send("B·∫°n kh√¥ng c√≥ quy·ªÅn ng·ª´ng theo d√µi k√™nh n√†y.", ephemeral=True)
            return
    
        await self.bot.loop.run_in_executor(None, db_remove_channel, channel.id)
        
        embed = discord.Embed(
            title="‚úÖ D·ª´ng theo d√µi", description=f"ƒê√£ ng·ª´ng theo d√µi k√™nh {channel.mention}.", color=discord.Color.red()
        )
        await ctx.send(embed=embed)

async def setup(bot: commands.Bot):
    await bot.add_cog(ChannelTracker(bot))
